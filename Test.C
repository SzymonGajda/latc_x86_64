/*** Compiler Front-End Test automatically generated by the BNF Converter ***/
/*                                                                          */
/* This test will parse a file, print the abstract syntax tree, and then    */
/* pretty-print the result.                                                 */
/*                                                                          */
/****************************************************************************/
#include <stdio.h>
#include <iostream>
#include "Parser.H"
#include "Printer.H"
#include "Absyn.H"
#include "TopDefAnalyser.H"
#include "Error.h"
#include "SemanticAnalyser.h"
#include "ThreeAddressCodeConverter.h"
#include "TACPrinter.h"
#include "BasicBlockConverter.h"

int main(int argc, char **argv) {
    FILE *input;
    if (argc > 1) {
        input = fopen(argv[1], "r");
        if (!input) {
            fprintf(stderr, "Error opening input file.\n");
            exit(1);
        }
    } else input = stdin;
    /* The default entry point is used. For other options see Parser.H */
    Program *parse_tree = pProgram(input);
    if (parse_tree) {
        FunctionHeaders *functionHeaders = new FunctionHeaders;
        TopDefAnalyser topDefAnalyser;
        topDefAnalyser.functionHeaders = functionHeaders;
        parse_tree->accept(&topDefAnalyser);
        if (topDefAnalyser.error.isError) {
            std::cout << topDefAnalyser.error.getErrorMessage();
            return 0;
        }
        SemanticAnalyser semanticAnalyser;
        Error *error = new Error;
        SymbolsTable *symbolsTable = new SymbolsTable;
        semanticAnalyser.functionHeaders = functionHeaders;
        semanticAnalyser.symbolsTable = symbolsTable;
        semanticAnalyser.error = error;
        parse_tree->accept(&semanticAnalyser);
        if (semanticAnalyser.error->isError) {
            std::cout << semanticAnalyser.error->getErrorMessage();
            return 0;
        }
        ThreeAddressCodeConverter *threeAddressCodeConverter = new ThreeAddressCodeConverter;
        threeAddressCodeConverter->functionHeaders = functionHeaders;
        symbolsTable = new SymbolsTable;
        threeAddressCodeConverter->symbolsTable = symbolsTable;
        parse_tree->accept(threeAddressCodeConverter);
        TACPrinter tacPrinter =  TACPrinter();
       // parse_tree->accept(&tacPrinter);
        BasicBlockConverter *basicBlockConverter = new BasicBlockConverter;
        basicBlockConverter->controlFlowGraph = new ControlFlowGraph;
        basicBlockConverter->stringValues = threeAddressCodeConverter->stringValues;
        basicBlockConverter->basicBlock = new BasicBlock;
        basicBlockConverter->tacPrinter = new TACPrinter;
        basicBlockConverter->functionHeaders = functionHeaders;
        basicBlockConverter->symbolsTable = symbolsTable;
        parse_tree->accept(basicBlockConverter);
        //parse_tree->accept(&tacPrinter);

        return 0;
    }
    return 1;
}

